/*
 * Clever-Cloud API
 *
 * Public API for managing Clever-Cloud data and products
 *
 * API version: 1.0.1
 * Contact: support@clever-cloud.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package clevercloud

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// AuthApiService AuthApi service
type AuthApiService service

type ApiAuthorizeFormRequest struct {
	ctx        _context.Context
	ApiService *AuthApiService
	ccid       *string
	cctk       *string
	oauthToken *string
	ccid2      *string
	cliToken   *string
	fromOauth  *string
}

func (r ApiAuthorizeFormRequest) Ccid(ccid string) ApiAuthorizeFormRequest {
	r.ccid = &ccid
	return r
}
func (r ApiAuthorizeFormRequest) Cctk(cctk string) ApiAuthorizeFormRequest {
	r.cctk = &cctk
	return r
}
func (r ApiAuthorizeFormRequest) OauthToken(oauthToken string) ApiAuthorizeFormRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiAuthorizeFormRequest) Ccid2(ccid2 string) ApiAuthorizeFormRequest {
	r.ccid2 = &ccid2
	return r
}
func (r ApiAuthorizeFormRequest) CliToken(cliToken string) ApiAuthorizeFormRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiAuthorizeFormRequest) FromOauth(fromOauth string) ApiAuthorizeFormRequest {
	r.fromOauth = &fromOauth
	return r
}

func (r ApiAuthorizeFormRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.AuthorizeFormExecute(r)
}

/*
 * AuthorizeForm Method for AuthorizeForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthorizeFormRequest
 */
func (a *AuthApiService) AuthorizeForm(ctx _context.Context) ApiAuthorizeFormRequest {
	return ApiAuthorizeFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *AuthApiService) AuthorizeFormExecute(r ApiAuthorizeFormRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.AuthorizeForm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.oauthToken != nil {
		localVarQueryParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.ccid2 != nil {
		localVarQueryParams.Add("ccid", parameterToString(*r.ccid2, ""))
	}
	if r.cliToken != nil {
		localVarQueryParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.fromOauth != nil {
		localVarQueryParams.Add("from_oauth", parameterToString(*r.fromOauth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizeTokenRequest struct {
	ctx                                      _context.Context
	ApiService                               *AuthApiService
	ccid                                     *string
	cctk                                     *string
	almighty                                 *string
	accessOrganisations                      *string
	manageOrganisations                      *string
	manageOrganisationsServices              *string
	manageOrganisationsApplications          *string
	manageOrganisationsMembers               *string
	accessOrganisationsBills                 *string
	accessOrganisationsCreditCount           *string
	accessOrganisationsConsumptionStatistics *string
	accessPersonalInformation                *string
	managePersonalInformation                *string
	manageSshKeys                            *string
}

func (r ApiAuthorizeTokenRequest) Ccid(ccid string) ApiAuthorizeTokenRequest {
	r.ccid = &ccid
	return r
}
func (r ApiAuthorizeTokenRequest) Cctk(cctk string) ApiAuthorizeTokenRequest {
	r.cctk = &cctk
	return r
}
func (r ApiAuthorizeTokenRequest) Almighty(almighty string) ApiAuthorizeTokenRequest {
	r.almighty = &almighty
	return r
}
func (r ApiAuthorizeTokenRequest) AccessOrganisations(accessOrganisations string) ApiAuthorizeTokenRequest {
	r.accessOrganisations = &accessOrganisations
	return r
}
func (r ApiAuthorizeTokenRequest) ManageOrganisations(manageOrganisations string) ApiAuthorizeTokenRequest {
	r.manageOrganisations = &manageOrganisations
	return r
}
func (r ApiAuthorizeTokenRequest) ManageOrganisationsServices(manageOrganisationsServices string) ApiAuthorizeTokenRequest {
	r.manageOrganisationsServices = &manageOrganisationsServices
	return r
}
func (r ApiAuthorizeTokenRequest) ManageOrganisationsApplications(manageOrganisationsApplications string) ApiAuthorizeTokenRequest {
	r.manageOrganisationsApplications = &manageOrganisationsApplications
	return r
}
func (r ApiAuthorizeTokenRequest) ManageOrganisationsMembers(manageOrganisationsMembers string) ApiAuthorizeTokenRequest {
	r.manageOrganisationsMembers = &manageOrganisationsMembers
	return r
}
func (r ApiAuthorizeTokenRequest) AccessOrganisationsBills(accessOrganisationsBills string) ApiAuthorizeTokenRequest {
	r.accessOrganisationsBills = &accessOrganisationsBills
	return r
}
func (r ApiAuthorizeTokenRequest) AccessOrganisationsCreditCount(accessOrganisationsCreditCount string) ApiAuthorizeTokenRequest {
	r.accessOrganisationsCreditCount = &accessOrganisationsCreditCount
	return r
}
func (r ApiAuthorizeTokenRequest) AccessOrganisationsConsumptionStatistics(accessOrganisationsConsumptionStatistics string) ApiAuthorizeTokenRequest {
	r.accessOrganisationsConsumptionStatistics = &accessOrganisationsConsumptionStatistics
	return r
}
func (r ApiAuthorizeTokenRequest) AccessPersonalInformation(accessPersonalInformation string) ApiAuthorizeTokenRequest {
	r.accessPersonalInformation = &accessPersonalInformation
	return r
}
func (r ApiAuthorizeTokenRequest) ManagePersonalInformation(managePersonalInformation string) ApiAuthorizeTokenRequest {
	r.managePersonalInformation = &managePersonalInformation
	return r
}
func (r ApiAuthorizeTokenRequest) ManageSshKeys(manageSshKeys string) ApiAuthorizeTokenRequest {
	r.manageSshKeys = &manageSshKeys
	return r
}

func (r ApiAuthorizeTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthorizeTokenExecute(r)
}

/*
 * AuthorizeToken Method for AuthorizeToken
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthorizeTokenRequest
 */
func (a *AuthApiService) AuthorizeToken(ctx _context.Context) ApiAuthorizeTokenRequest {
	return ApiAuthorizeTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthApiService) AuthorizeTokenExecute(r ApiAuthorizeTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.AuthorizeToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.almighty != nil {
		localVarFormParams.Add("almighty", parameterToString(*r.almighty, ""))
	}
	if r.accessOrganisations != nil {
		localVarFormParams.Add("access_organisations", parameterToString(*r.accessOrganisations, ""))
	}
	if r.manageOrganisations != nil {
		localVarFormParams.Add("manage_organisations", parameterToString(*r.manageOrganisations, ""))
	}
	if r.manageOrganisationsServices != nil {
		localVarFormParams.Add("manage_organisations_services", parameterToString(*r.manageOrganisationsServices, ""))
	}
	if r.manageOrganisationsApplications != nil {
		localVarFormParams.Add("manage_organisations_applications", parameterToString(*r.manageOrganisationsApplications, ""))
	}
	if r.manageOrganisationsMembers != nil {
		localVarFormParams.Add("manage_organisations_members", parameterToString(*r.manageOrganisationsMembers, ""))
	}
	if r.accessOrganisationsBills != nil {
		localVarFormParams.Add("access_organisations_bills", parameterToString(*r.accessOrganisationsBills, ""))
	}
	if r.accessOrganisationsCreditCount != nil {
		localVarFormParams.Add("access_organisations_credit_count", parameterToString(*r.accessOrganisationsCreditCount, ""))
	}
	if r.accessOrganisationsConsumptionStatistics != nil {
		localVarFormParams.Add("access_organisations_consumption_statistics", parameterToString(*r.accessOrganisationsConsumptionStatistics, ""))
	}
	if r.accessPersonalInformation != nil {
		localVarFormParams.Add("access_personal_information", parameterToString(*r.accessPersonalInformation, ""))
	}
	if r.managePersonalInformation != nil {
		localVarFormParams.Add("manage_personal_information", parameterToString(*r.managePersonalInformation, ""))
	}
	if r.manageSshKeys != nil {
		localVarFormParams.Add("manage_ssh_keys", parameterToString(*r.manageSshKeys, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAvailableRightsRequest struct {
	ctx        _context.Context
	ApiService *AuthApiService
}

func (r ApiGetAvailableRightsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAvailableRightsExecute(r)
}

/*
 * GetAvailableRights Method for GetAvailableRights
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAvailableRightsRequest
 */
func (a *AuthApiService) GetAvailableRights(ctx _context.Context) ApiGetAvailableRightsRequest {
	return ApiGetAvailableRightsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthApiService) GetAvailableRightsExecute(r ApiGetAvailableRightsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.GetAvailableRights")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/rights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLoginDataRequest struct {
	ctx        _context.Context
	ApiService *AuthApiService
	oauthKey   *string
}

func (r ApiGetLoginDataRequest) OauthKey(oauthKey string) ApiGetLoginDataRequest {
	r.oauthKey = &oauthKey
	return r
}

func (r ApiGetLoginDataRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetLoginDataExecute(r)
}

/*
 * GetLoginData Method for GetLoginData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetLoginDataRequest
 */
func (a *AuthApiService) GetLoginData(ctx _context.Context) ApiGetLoginDataRequest {
	return ApiGetLoginDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthApiService) GetLoginDataExecute(r ApiGetLoginDataRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.GetLoginData")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/login_data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.oauthKey != nil {
		localVarQueryParams.Add("oauth_key", parameterToString(*r.oauthKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAccessTokenRequestRequest struct {
	ctx                    _context.Context
	ApiService             *AuthApiService
	oauthConsumerKey       *string
	oauthToken             *string
	oauthSignatureMethod   *string
	oauthSignature         *string
	oauthTimestamp         *string
	oauthNonce             *string
	oauthVersion           *string
	oauthVerifier          *string
	oauthCallback          *string
	oauthTokenSecret       *string
	oauthCallbackConfirmed *string
}

func (r ApiPostAccessTokenRequestRequest) OauthConsumerKey(oauthConsumerKey string) ApiPostAccessTokenRequestRequest {
	r.oauthConsumerKey = &oauthConsumerKey
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthToken(oauthToken string) ApiPostAccessTokenRequestRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthSignatureMethod(oauthSignatureMethod string) ApiPostAccessTokenRequestRequest {
	r.oauthSignatureMethod = &oauthSignatureMethod
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthSignature(oauthSignature string) ApiPostAccessTokenRequestRequest {
	r.oauthSignature = &oauthSignature
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthTimestamp(oauthTimestamp string) ApiPostAccessTokenRequestRequest {
	r.oauthTimestamp = &oauthTimestamp
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthNonce(oauthNonce string) ApiPostAccessTokenRequestRequest {
	r.oauthNonce = &oauthNonce
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthVersion(oauthVersion string) ApiPostAccessTokenRequestRequest {
	r.oauthVersion = &oauthVersion
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthVerifier(oauthVerifier string) ApiPostAccessTokenRequestRequest {
	r.oauthVerifier = &oauthVerifier
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthCallback(oauthCallback string) ApiPostAccessTokenRequestRequest {
	r.oauthCallback = &oauthCallback
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthTokenSecret(oauthTokenSecret string) ApiPostAccessTokenRequestRequest {
	r.oauthTokenSecret = &oauthTokenSecret
	return r
}
func (r ApiPostAccessTokenRequestRequest) OauthCallbackConfirmed(oauthCallbackConfirmed string) ApiPostAccessTokenRequestRequest {
	r.oauthCallbackConfirmed = &oauthCallbackConfirmed
	return r
}

func (r ApiPostAccessTokenRequestRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostAccessTokenRequestExecute(r)
}

/*
 * PostAccessTokenRequest Method for PostAccessTokenRequest
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostAccessTokenRequestRequest
 */
func (a *AuthApiService) PostAccessTokenRequest(ctx _context.Context) ApiPostAccessTokenRequestRequest {
	return ApiPostAccessTokenRequestRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthApiService) PostAccessTokenRequestExecute(r ApiPostAccessTokenRequestRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.PostAccessTokenRequest")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/access_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-www-form-urlencoded"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.oauthConsumerKey != nil {
		localVarFormParams.Add("oauth_consumer_key", parameterToString(*r.oauthConsumerKey, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.oauthSignatureMethod != nil {
		localVarFormParams.Add("oauth_signature_method", parameterToString(*r.oauthSignatureMethod, ""))
	}
	if r.oauthSignature != nil {
		localVarFormParams.Add("oauth_signature", parameterToString(*r.oauthSignature, ""))
	}
	if r.oauthTimestamp != nil {
		localVarFormParams.Add("oauth_timestamp", parameterToString(*r.oauthTimestamp, ""))
	}
	if r.oauthNonce != nil {
		localVarFormParams.Add("oauth_nonce", parameterToString(*r.oauthNonce, ""))
	}
	if r.oauthVersion != nil {
		localVarFormParams.Add("oauth_version", parameterToString(*r.oauthVersion, ""))
	}
	if r.oauthVerifier != nil {
		localVarFormParams.Add("oauth_verifier", parameterToString(*r.oauthVerifier, ""))
	}
	if r.oauthCallback != nil {
		localVarFormParams.Add("oauth_callback", parameterToString(*r.oauthCallback, ""))
	}
	if r.oauthTokenSecret != nil {
		localVarFormParams.Add("oauth_token_secret", parameterToString(*r.oauthTokenSecret, ""))
	}
	if r.oauthCallbackConfirmed != nil {
		localVarFormParams.Add("oauth_callback_confirmed", parameterToString(*r.oauthCallbackConfirmed, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAccessTokenRequestQueryRequest struct {
	ctx                    _context.Context
	ApiService             *AuthApiService
	oauthConsumerKey       *string
	oauthToken             *string
	oauthSignatureMethod   *string
	oauthSignature         *string
	oauthTimestamp         *string
	oauthNonce             *string
	oauthVersion           *string
	oauthVerifier          *string
	oauthCallback          *string
	oauthTokenSecret       *string
	oauthCallbackConfirmed *string
}

func (r ApiPostAccessTokenRequestQueryRequest) OauthConsumerKey(oauthConsumerKey string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthConsumerKey = &oauthConsumerKey
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthToken(oauthToken string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthSignatureMethod(oauthSignatureMethod string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthSignatureMethod = &oauthSignatureMethod
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthSignature(oauthSignature string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthSignature = &oauthSignature
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthTimestamp(oauthTimestamp string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthTimestamp = &oauthTimestamp
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthNonce(oauthNonce string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthNonce = &oauthNonce
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthVersion(oauthVersion string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthVersion = &oauthVersion
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthVerifier(oauthVerifier string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthVerifier = &oauthVerifier
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthCallback(oauthCallback string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthCallback = &oauthCallback
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthTokenSecret(oauthTokenSecret string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthTokenSecret = &oauthTokenSecret
	return r
}
func (r ApiPostAccessTokenRequestQueryRequest) OauthCallbackConfirmed(oauthCallbackConfirmed string) ApiPostAccessTokenRequestQueryRequest {
	r.oauthCallbackConfirmed = &oauthCallbackConfirmed
	return r
}

func (r ApiPostAccessTokenRequestQueryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostAccessTokenRequestQueryExecute(r)
}

/*
 * PostAccessTokenRequestQuery Method for PostAccessTokenRequestQuery
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostAccessTokenRequestQueryRequest
 */
func (a *AuthApiService) PostAccessTokenRequestQuery(ctx _context.Context) ApiPostAccessTokenRequestQueryRequest {
	return ApiPostAccessTokenRequestQueryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AuthApiService) PostAccessTokenRequestQueryExecute(r ApiPostAccessTokenRequestQueryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.PostAccessTokenRequestQuery")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/access_token_query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.oauthConsumerKey != nil {
		localVarQueryParams.Add("oauth_consumer_key", parameterToString(*r.oauthConsumerKey, ""))
	}
	if r.oauthToken != nil {
		localVarQueryParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.oauthSignatureMethod != nil {
		localVarQueryParams.Add("oauth_signature_method", parameterToString(*r.oauthSignatureMethod, ""))
	}
	if r.oauthSignature != nil {
		localVarQueryParams.Add("oauth_signature", parameterToString(*r.oauthSignature, ""))
	}
	if r.oauthTimestamp != nil {
		localVarQueryParams.Add("oauth_timestamp", parameterToString(*r.oauthTimestamp, ""))
	}
	if r.oauthNonce != nil {
		localVarQueryParams.Add("oauth_nonce", parameterToString(*r.oauthNonce, ""))
	}
	if r.oauthVersion != nil {
		localVarQueryParams.Add("oauth_version", parameterToString(*r.oauthVersion, ""))
	}
	if r.oauthVerifier != nil {
		localVarQueryParams.Add("oauth_verifier", parameterToString(*r.oauthVerifier, ""))
	}
	if r.oauthCallback != nil {
		localVarQueryParams.Add("oauth_callback", parameterToString(*r.oauthCallback, ""))
	}
	if r.oauthTokenSecret != nil {
		localVarQueryParams.Add("oauth_token_secret", parameterToString(*r.oauthTokenSecret, ""))
	}
	if r.oauthCallbackConfirmed != nil {
		localVarQueryParams.Add("oauth_callback_confirmed", parameterToString(*r.oauthCallbackConfirmed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-www-form-urlencoded"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAuthorizeRequest struct {
	ctx                  _context.Context
	ApiService           *AuthApiService
	wannabeAuthorization *WannabeAuthorization
}

func (r ApiPostAuthorizeRequest) WannabeAuthorization(wannabeAuthorization WannabeAuthorization) ApiPostAuthorizeRequest {
	r.wannabeAuthorization = &wannabeAuthorization
	return r
}

func (r ApiPostAuthorizeRequest) Execute() (Message, *_nethttp.Response, error) {
	return r.ApiService.PostAuthorizeExecute(r)
}

/*
 * PostAuthorize Method for PostAuthorize
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostAuthorizeRequest
 */
func (a *AuthApiService) PostAuthorize(ctx _context.Context) ApiPostAuthorizeRequest {
	return ApiPostAuthorizeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Message
 */
func (a *AuthApiService) PostAuthorizeExecute(r ApiPostAuthorizeRequest) (Message, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.PostAuthorize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.wannabeAuthorization == nil {
		return localVarReturnValue, nil, reportError("wannabeAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wannabeAuthorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReqTokenRequestRequest struct {
	ctx                    _context.Context
	ApiService             *AuthApiService
	cleverFlavor           *string
	oauthConsumerKey       *string
	oauthToken             *string
	oauthSignatureMethod   *string
	oauthSignature         *string
	oauthTimestamp         *string
	oauthNonce             *string
	oauthVersion           *string
	oauthVerifier          *string
	oauthCallback          *string
	oauthTokenSecret       *string
	oauthCallbackConfirmed *string
}

func (r ApiPostReqTokenRequestRequest) CleverFlavor(cleverFlavor string) ApiPostReqTokenRequestRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthConsumerKey(oauthConsumerKey string) ApiPostReqTokenRequestRequest {
	r.oauthConsumerKey = &oauthConsumerKey
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthToken(oauthToken string) ApiPostReqTokenRequestRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthSignatureMethod(oauthSignatureMethod string) ApiPostReqTokenRequestRequest {
	r.oauthSignatureMethod = &oauthSignatureMethod
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthSignature(oauthSignature string) ApiPostReqTokenRequestRequest {
	r.oauthSignature = &oauthSignature
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthTimestamp(oauthTimestamp string) ApiPostReqTokenRequestRequest {
	r.oauthTimestamp = &oauthTimestamp
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthNonce(oauthNonce string) ApiPostReqTokenRequestRequest {
	r.oauthNonce = &oauthNonce
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthVersion(oauthVersion string) ApiPostReqTokenRequestRequest {
	r.oauthVersion = &oauthVersion
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthVerifier(oauthVerifier string) ApiPostReqTokenRequestRequest {
	r.oauthVerifier = &oauthVerifier
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthCallback(oauthCallback string) ApiPostReqTokenRequestRequest {
	r.oauthCallback = &oauthCallback
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthTokenSecret(oauthTokenSecret string) ApiPostReqTokenRequestRequest {
	r.oauthTokenSecret = &oauthTokenSecret
	return r
}
func (r ApiPostReqTokenRequestRequest) OauthCallbackConfirmed(oauthCallbackConfirmed string) ApiPostReqTokenRequestRequest {
	r.oauthCallbackConfirmed = &oauthCallbackConfirmed
	return r
}

func (r ApiPostReqTokenRequestRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostReqTokenRequestExecute(r)
}

/*
 * PostReqTokenRequest Method for PostReqTokenRequest
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostReqTokenRequestRequest
 */
func (a *AuthApiService) PostReqTokenRequest(ctx _context.Context) ApiPostReqTokenRequestRequest {
	return ApiPostReqTokenRequestRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *AuthApiService) PostReqTokenRequestExecute(r ApiPostReqTokenRequestRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.PostReqTokenRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/request_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-www-form-urlencoded"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.oauthConsumerKey != nil {
		localVarFormParams.Add("oauth_consumer_key", parameterToString(*r.oauthConsumerKey, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.oauthSignatureMethod != nil {
		localVarFormParams.Add("oauth_signature_method", parameterToString(*r.oauthSignatureMethod, ""))
	}
	if r.oauthSignature != nil {
		localVarFormParams.Add("oauth_signature", parameterToString(*r.oauthSignature, ""))
	}
	if r.oauthTimestamp != nil {
		localVarFormParams.Add("oauth_timestamp", parameterToString(*r.oauthTimestamp, ""))
	}
	if r.oauthNonce != nil {
		localVarFormParams.Add("oauth_nonce", parameterToString(*r.oauthNonce, ""))
	}
	if r.oauthVersion != nil {
		localVarFormParams.Add("oauth_version", parameterToString(*r.oauthVersion, ""))
	}
	if r.oauthVerifier != nil {
		localVarFormParams.Add("oauth_verifier", parameterToString(*r.oauthVerifier, ""))
	}
	if r.oauthCallback != nil {
		localVarFormParams.Add("oauth_callback", parameterToString(*r.oauthCallback, ""))
	}
	if r.oauthTokenSecret != nil {
		localVarFormParams.Add("oauth_token_secret", parameterToString(*r.oauthTokenSecret, ""))
	}
	if r.oauthCallbackConfirmed != nil {
		localVarFormParams.Add("oauth_callback_confirmed", parameterToString(*r.oauthCallbackConfirmed, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReqTokenRequestQueryStringRequest struct {
	ctx                    _context.Context
	ApiService             *AuthApiService
	cleverFlavor           *string
	oauthConsumerKey       *string
	oauthToken             *string
	oauthSignatureMethod   *string
	oauthSignature         *string
	oauthTimestamp         *string
	oauthNonce             *string
	oauthVersion           *string
	oauthVerifier          *string
	oauthCallback          *string
	oauthTokenSecret       *string
	oauthCallbackConfirmed *string
}

func (r ApiPostReqTokenRequestQueryStringRequest) CleverFlavor(cleverFlavor string) ApiPostReqTokenRequestQueryStringRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthConsumerKey(oauthConsumerKey string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthConsumerKey = &oauthConsumerKey
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthToken(oauthToken string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthSignatureMethod(oauthSignatureMethod string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthSignatureMethod = &oauthSignatureMethod
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthSignature(oauthSignature string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthSignature = &oauthSignature
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthTimestamp(oauthTimestamp string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthTimestamp = &oauthTimestamp
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthNonce(oauthNonce string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthNonce = &oauthNonce
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthVersion(oauthVersion string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthVersion = &oauthVersion
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthVerifier(oauthVerifier string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthVerifier = &oauthVerifier
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthCallback(oauthCallback string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthCallback = &oauthCallback
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthTokenSecret(oauthTokenSecret string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthTokenSecret = &oauthTokenSecret
	return r
}
func (r ApiPostReqTokenRequestQueryStringRequest) OauthCallbackConfirmed(oauthCallbackConfirmed string) ApiPostReqTokenRequestQueryStringRequest {
	r.oauthCallbackConfirmed = &oauthCallbackConfirmed
	return r
}

func (r ApiPostReqTokenRequestQueryStringRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostReqTokenRequestQueryStringExecute(r)
}

/*
 * PostReqTokenRequestQueryString Method for PostReqTokenRequestQueryString
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostReqTokenRequestQueryStringRequest
 */
func (a *AuthApiService) PostReqTokenRequestQueryString(ctx _context.Context) ApiPostReqTokenRequestQueryStringRequest {
	return ApiPostReqTokenRequestQueryStringRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *AuthApiService) PostReqTokenRequestQueryStringExecute(r ApiPostReqTokenRequestQueryStringRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.PostReqTokenRequestQueryString")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/request_token_query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthConsumerKey != nil {
		localVarQueryParams.Add("oauth_consumer_key", parameterToString(*r.oauthConsumerKey, ""))
	}
	if r.oauthToken != nil {
		localVarQueryParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.oauthSignatureMethod != nil {
		localVarQueryParams.Add("oauth_signature_method", parameterToString(*r.oauthSignatureMethod, ""))
	}
	if r.oauthSignature != nil {
		localVarQueryParams.Add("oauth_signature", parameterToString(*r.oauthSignature, ""))
	}
	if r.oauthTimestamp != nil {
		localVarQueryParams.Add("oauth_timestamp", parameterToString(*r.oauthTimestamp, ""))
	}
	if r.oauthNonce != nil {
		localVarQueryParams.Add("oauth_nonce", parameterToString(*r.oauthNonce, ""))
	}
	if r.oauthVersion != nil {
		localVarQueryParams.Add("oauth_version", parameterToString(*r.oauthVersion, ""))
	}
	if r.oauthVerifier != nil {
		localVarQueryParams.Add("oauth_verifier", parameterToString(*r.oauthVerifier, ""))
	}
	if r.oauthCallback != nil {
		localVarQueryParams.Add("oauth_callback", parameterToString(*r.oauthCallback, ""))
	}
	if r.oauthTokenSecret != nil {
		localVarQueryParams.Add("oauth_token_secret", parameterToString(*r.oauthTokenSecret, ""))
	}
	if r.oauthCallbackConfirmed != nil {
		localVarQueryParams.Add("oauth_callback_confirmed", parameterToString(*r.oauthCallbackConfirmed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-www-form-urlencoded"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
