/*
 * Clever-Cloud API
 *
 * Public API for managing Clever-Cloud data and products
 *
 * API version: 1.0.1
 * Contact: support@clever-cloud.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package clevercloud

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UserApiService UserApi service
type UserApiService service

type ApiAskForPasswordResetViaFormRequest struct {
	ctx          _context.Context
	ApiService   *UserApiService
	login        *string
	dropTokens   *string
	cleverFlavor *string
}

func (r ApiAskForPasswordResetViaFormRequest) Login(login string) ApiAskForPasswordResetViaFormRequest {
	r.login = &login
	return r
}
func (r ApiAskForPasswordResetViaFormRequest) DropTokens(dropTokens string) ApiAskForPasswordResetViaFormRequest {
	r.dropTokens = &dropTokens
	return r
}
func (r ApiAskForPasswordResetViaFormRequest) CleverFlavor(cleverFlavor string) ApiAskForPasswordResetViaFormRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiAskForPasswordResetViaFormRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.AskForPasswordResetViaFormExecute(r)
}

/*
 * AskForPasswordResetViaForm Method for AskForPasswordResetViaForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAskForPasswordResetViaFormRequest
 */
func (a *UserApiService) AskForPasswordResetViaForm(ctx _context.Context) ApiAskForPasswordResetViaFormRequest {
	return ApiAskForPasswordResetViaFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) AskForPasswordResetViaFormExecute(r ApiAskForPasswordResetViaFormRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.AskForPasswordResetViaForm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/password_forgotten"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.login != nil {
		localVarFormParams.Add("login", parameterToString(*r.login, ""))
	}
	if r.dropTokens != nil {
		localVarFormParams.Add("drop_tokens", parameterToString(*r.dropTokens, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizePaypalTransactionRequest struct {
	ctx         _context.Context
	ApiService  *UserApiService
	bid         string
	paymentData *PaymentData
}

func (r ApiAuthorizePaypalTransactionRequest) PaymentData(paymentData PaymentData) ApiAuthorizePaypalTransactionRequest {
	r.paymentData = &paymentData
	return r
}

func (r ApiAuthorizePaypalTransactionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AuthorizePaypalTransactionExecute(r)
}

/*
 * AuthorizePaypalTransaction Method for AuthorizePaypalTransaction
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bid
 * @return ApiAuthorizePaypalTransactionRequest
 */
func (a *UserApiService) AuthorizePaypalTransaction(ctx _context.Context, bid string) ApiAuthorizePaypalTransactionRequest {
	return ApiAuthorizePaypalTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		bid:        bid,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) AuthorizePaypalTransactionExecute(r ApiAuthorizePaypalTransactionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.AuthorizePaypalTransaction")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoice/external/paypal/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", _neturl.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.paymentData == nil {
		return nil, reportError("paymentData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCancelPaypalTransactionRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	bid        string
}

func (r ApiCancelPaypalTransactionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CancelPaypalTransactionExecute(r)
}

/*
 * CancelPaypalTransaction Method for CancelPaypalTransaction
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bid
 * @return ApiCancelPaypalTransactionRequest
 */
func (a *UserApiService) CancelPaypalTransaction(ctx _context.Context, bid string) ApiCancelPaypalTransactionRequest {
	return ApiCancelPaypalTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		bid:        bid,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) CancelPaypalTransactionExecute(r ApiCancelPaypalTransactionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.CancelPaypalTransaction")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoice/external/paypal/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", _neturl.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfirmPasswordResetRequestRequest struct {
	ctx          _context.Context
	ApiService   *UserApiService
	key          string
	cleverFlavor *string
}

func (r ApiConfirmPasswordResetRequestRequest) CleverFlavor(cleverFlavor string) ApiConfirmPasswordResetRequestRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiConfirmPasswordResetRequestRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.ConfirmPasswordResetRequestExecute(r)
}

/*
 * ConfirmPasswordResetRequest Method for ConfirmPasswordResetRequest
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param key
 * @return ApiConfirmPasswordResetRequestRequest
 */
func (a *UserApiService) ConfirmPasswordResetRequest(ctx _context.Context, key string) ApiConfirmPasswordResetRequestRequest {
	return ApiConfirmPasswordResetRequestRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) ConfirmPasswordResetRequestExecute(r ApiConfirmPasswordResetRequestRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.ConfirmPasswordResetRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/password_forgotten/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserFromFormRequest struct {
	ctx                    _context.Context
	ApiService             *UserApiService
	invitationKey          *string
	addonBetaInvitationKey *string
	email                  *string
	pass                   *string
	urlNext                *string
	terms                  *string
	subscriptionSource     *string
	cleverFlavor           *string
	oauthToken             *string
}

func (r ApiCreateUserFromFormRequest) InvitationKey(invitationKey string) ApiCreateUserFromFormRequest {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiCreateUserFromFormRequest) AddonBetaInvitationKey(addonBetaInvitationKey string) ApiCreateUserFromFormRequest {
	r.addonBetaInvitationKey = &addonBetaInvitationKey
	return r
}
func (r ApiCreateUserFromFormRequest) Email(email string) ApiCreateUserFromFormRequest {
	r.email = &email
	return r
}
func (r ApiCreateUserFromFormRequest) Pass(pass string) ApiCreateUserFromFormRequest {
	r.pass = &pass
	return r
}
func (r ApiCreateUserFromFormRequest) UrlNext(urlNext string) ApiCreateUserFromFormRequest {
	r.urlNext = &urlNext
	return r
}
func (r ApiCreateUserFromFormRequest) Terms(terms string) ApiCreateUserFromFormRequest {
	r.terms = &terms
	return r
}
func (r ApiCreateUserFromFormRequest) SubscriptionSource(subscriptionSource string) ApiCreateUserFromFormRequest {
	r.subscriptionSource = &subscriptionSource
	return r
}
func (r ApiCreateUserFromFormRequest) CleverFlavor(cleverFlavor string) ApiCreateUserFromFormRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiCreateUserFromFormRequest) OauthToken(oauthToken string) ApiCreateUserFromFormRequest {
	r.oauthToken = &oauthToken
	return r
}

func (r ApiCreateUserFromFormRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateUserFromFormExecute(r)
}

/*
 * CreateUserFromForm Method for CreateUserFromForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateUserFromFormRequest
 */
func (a *UserApiService) CreateUserFromForm(ctx _context.Context) ApiCreateUserFromFormRequest {
	return ApiCreateUserFromFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) CreateUserFromFormExecute(r ApiCreateUserFromFormRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.CreateUserFromForm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.invitationKey != nil {
		localVarFormParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.addonBetaInvitationKey != nil {
		localVarFormParams.Add("addonBetaInvitationKey", parameterToString(*r.addonBetaInvitationKey, ""))
	}
	if r.email != nil {
		localVarFormParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.pass != nil {
		localVarFormParams.Add("pass", parameterToString(*r.pass, ""))
	}
	if r.urlNext != nil {
		localVarFormParams.Add("url_next", parameterToString(*r.urlNext, ""))
	}
	if r.terms != nil {
		localVarFormParams.Add("terms", parameterToString(*r.terms, ""))
	}
	if r.subscriptionSource != nil {
		localVarFormParams.Add("subscription_source", parameterToString(*r.subscriptionSource, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGithubLinkRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiDeleteGithubLinkRequest) Execute() (Message, *_nethttp.Response, error) {
	return r.ApiService.DeleteGithubLinkExecute(r)
}

/*
 * DeleteGithubLink Method for DeleteGithubLink
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeleteGithubLinkRequest
 */
func (a *UserApiService) DeleteGithubLink(ctx _context.Context) ApiDeleteGithubLinkRequest {
	return ApiDeleteGithubLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Message
 */
func (a *UserApiService) DeleteGithubLinkExecute(r ApiDeleteGithubLinkRequest) (Message, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.DeleteGithubLink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/link"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinsihGithubSignupRequest struct {
	ctx           _context.Context
	ApiService    *UserApiService
	transactionId *string
	name          *string
	otherId       *string
	otherEmail    *string
	password      *string
	autoLink      *string
	terms         *string
	invitationKey *string
	mfaKind       *string
	mfaAttempt    *string
}

func (r ApiFinsihGithubSignupRequest) TransactionId(transactionId string) ApiFinsihGithubSignupRequest {
	r.transactionId = &transactionId
	return r
}
func (r ApiFinsihGithubSignupRequest) Name(name string) ApiFinsihGithubSignupRequest {
	r.name = &name
	return r
}
func (r ApiFinsihGithubSignupRequest) OtherId(otherId string) ApiFinsihGithubSignupRequest {
	r.otherId = &otherId
	return r
}
func (r ApiFinsihGithubSignupRequest) OtherEmail(otherEmail string) ApiFinsihGithubSignupRequest {
	r.otherEmail = &otherEmail
	return r
}
func (r ApiFinsihGithubSignupRequest) Password(password string) ApiFinsihGithubSignupRequest {
	r.password = &password
	return r
}
func (r ApiFinsihGithubSignupRequest) AutoLink(autoLink string) ApiFinsihGithubSignupRequest {
	r.autoLink = &autoLink
	return r
}
func (r ApiFinsihGithubSignupRequest) Terms(terms string) ApiFinsihGithubSignupRequest {
	r.terms = &terms
	return r
}
func (r ApiFinsihGithubSignupRequest) InvitationKey(invitationKey string) ApiFinsihGithubSignupRequest {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiFinsihGithubSignupRequest) MfaKind(mfaKind string) ApiFinsihGithubSignupRequest {
	r.mfaKind = &mfaKind
	return r
}
func (r ApiFinsihGithubSignupRequest) MfaAttempt(mfaAttempt string) ApiFinsihGithubSignupRequest {
	r.mfaAttempt = &mfaAttempt
	return r
}

func (r ApiFinsihGithubSignupRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.FinsihGithubSignupExecute(r)
}

/*
 * FinsihGithubSignup Method for FinsihGithubSignup
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFinsihGithubSignupRequest
 */
func (a *UserApiService) FinsihGithubSignup(ctx _context.Context) ApiFinsihGithubSignupRequest {
	return ApiFinsihGithubSignupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) FinsihGithubSignupExecute(r ApiFinsihGithubSignupRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.FinsihGithubSignup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/signup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.transactionId != nil {
		localVarFormParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.otherId != nil {
		localVarFormParams.Add("otherId", parameterToString(*r.otherId, ""))
	}
	if r.otherEmail != nil {
		localVarFormParams.Add("otherEmail", parameterToString(*r.otherEmail, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.autoLink != nil {
		localVarFormParams.Add("autoLink", parameterToString(*r.autoLink, ""))
	}
	if r.terms != nil {
		localVarFormParams.Add("terms", parameterToString(*r.terms, ""))
	}
	if r.invitationKey != nil {
		localVarFormParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.mfaKind != nil {
		localVarFormParams.Add("mfa_kind", parameterToString(*r.mfaKind, ""))
	}
	if r.mfaAttempt != nil {
		localVarFormParams.Add("mfa_attempt", parameterToString(*r.mfaAttempt, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationsRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	id         string
}

func (r ApiGetApplicationsRequest) Execute() ([]ApplicationView, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationsExecute(r)
}

/*
 * GetApplications Method for GetApplications
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGetApplicationsRequest
 */
func (a *UserApiService) GetApplications(ctx _context.Context, id string) ApiGetApplicationsRequest {
	return ApiGetApplicationsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return []ApplicationView
 */
func (a *UserApiService) GetApplicationsExecute(r ApiGetApplicationsRequest) ([]ApplicationView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ApplicationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetApplications")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{id}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnvRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	appId      string
	token      *string
}

func (r ApiGetEnvRequest) Token(token string) ApiGetEnvRequest {
	r.token = &token
	return r
}

func (r ApiGetEnvRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetEnvExecute(r)
}

/*
 * GetEnv Method for GetEnv
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId
 * @return ApiGetEnvRequest
 */
func (a *UserApiService) GetEnv(ctx _context.Context, appId string) ApiGetEnvRequest {
	return ApiGetEnvRequest{
		ApiService: a,
		ctx:        ctx,
		appId:      appId,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetEnvExecute(r ApiGetEnvRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetEnv")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/application/{appId}/environment"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", _neturl.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGitInfoRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	userId     string
}

func (r ApiGetGitInfoRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetGitInfoExecute(r)
}

/*
 * GetGitInfo Method for GetGitInfo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @return ApiGetGitInfoRequest
 */
func (a *UserApiService) GetGitInfo(ctx _context.Context, userId string) ApiGetGitInfoRequest {
	return ApiGetGitInfoRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetGitInfoExecute(r ApiGetGitInfoRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGitInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/git-info"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiGetGithubRequest) Execute() (OAuthTransactionView, *_nethttp.Response, error) {
	return r.ApiService.GetGithubExecute(r)
}

/*
 * GetGithub Method for GetGithub
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubRequest
 */
func (a *UserApiService) GetGithub(ctx _context.Context) ApiGetGithubRequest {
	return ApiGetGithubRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OAuthTransactionView
 */
func (a *UserApiService) GetGithubExecute(r ApiGetGithubRequest) (OAuthTransactionView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OAuthTransactionView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithub")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubApplicationsRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiGetGithubApplicationsRequest) Execute() ([]OAuthApplicationView, *_nethttp.Response, error) {
	return r.ApiService.GetGithubApplicationsExecute(r)
}

/*
 * GetGithubApplications Method for GetGithubApplications
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubApplicationsRequest
 */
func (a *UserApiService) GetGithubApplications(ctx _context.Context) ApiGetGithubApplicationsRequest {
	return ApiGetGithubApplicationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OAuthApplicationView
 */
func (a *UserApiService) GetGithubApplicationsExecute(r ApiGetGithubApplicationsRequest) ([]OAuthApplicationView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OAuthApplicationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubApplications")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubCallbackRequest struct {
	ctx              _context.Context
	ApiService       *UserApiService
	ccOAuthData      *string
	code             *string
	state            *string
	error_           *string
	errorDescription *string
	errorUri         *string
}

func (r ApiGetGithubCallbackRequest) CcOAuthData(ccOAuthData string) ApiGetGithubCallbackRequest {
	r.ccOAuthData = &ccOAuthData
	return r
}
func (r ApiGetGithubCallbackRequest) Code(code string) ApiGetGithubCallbackRequest {
	r.code = &code
	return r
}
func (r ApiGetGithubCallbackRequest) State(state string) ApiGetGithubCallbackRequest {
	r.state = &state
	return r
}
func (r ApiGetGithubCallbackRequest) Error_(error_ string) ApiGetGithubCallbackRequest {
	r.error_ = &error_
	return r
}
func (r ApiGetGithubCallbackRequest) ErrorDescription(errorDescription string) ApiGetGithubCallbackRequest {
	r.errorDescription = &errorDescription
	return r
}
func (r ApiGetGithubCallbackRequest) ErrorUri(errorUri string) ApiGetGithubCallbackRequest {
	r.errorUri = &errorUri
	return r
}

func (r ApiGetGithubCallbackRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetGithubCallbackExecute(r)
}

/*
 * GetGithubCallback Method for GetGithubCallback
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubCallbackRequest
 */
func (a *UserApiService) GetGithubCallback(ctx _context.Context) ApiGetGithubCallbackRequest {
	return ApiGetGithubCallbackRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) GetGithubCallbackExecute(r ApiGetGithubCallbackRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubCallback")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/callback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.error_ != nil {
		localVarQueryParams.Add("error", parameterToString(*r.error_, ""))
	}
	if r.errorDescription != nil {
		localVarQueryParams.Add("error_description", parameterToString(*r.errorDescription, ""))
	}
	if r.errorUri != nil {
		localVarQueryParams.Add("error_uri", parameterToString(*r.errorUri, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGithubEmailsRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiGetGithubEmailsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetGithubEmailsExecute(r)
}

/*
 * GetGithubEmails Method for GetGithubEmails
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubEmailsRequest
 */
func (a *UserApiService) GetGithubEmails(ctx _context.Context) ApiGetGithubEmailsRequest {
	return ApiGetGithubEmailsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []string
 */
func (a *UserApiService) GetGithubEmailsExecute(r ApiGetGithubEmailsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubEmails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/emails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubKeysRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiGetGithubKeysRequest) Execute() ([]SshKeyView, *_nethttp.Response, error) {
	return r.ApiService.GetGithubKeysExecute(r)
}

/*
 * GetGithubKeys Method for GetGithubKeys
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubKeysRequest
 */
func (a *UserApiService) GetGithubKeys(ctx _context.Context) ApiGetGithubKeysRequest {
	return ApiGetGithubKeysRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []SshKeyView
 */
func (a *UserApiService) GetGithubKeysExecute(r ApiGetGithubKeysRequest) ([]SshKeyView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SshKeyView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubKeys")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubLinkRequest struct {
	ctx           _context.Context
	ApiService    *UserApiService
	transactionId *string
	redirectUrl   *string
}

func (r ApiGetGithubLinkRequest) TransactionId(transactionId string) ApiGetGithubLinkRequest {
	r.transactionId = &transactionId
	return r
}
func (r ApiGetGithubLinkRequest) RedirectUrl(redirectUrl string) ApiGetGithubLinkRequest {
	r.redirectUrl = &redirectUrl
	return r
}

func (r ApiGetGithubLinkRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetGithubLinkExecute(r)
}

/*
 * GetGithubLink Method for GetGithubLink
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubLinkRequest
 */
func (a *UserApiService) GetGithubLink(ctx _context.Context) ApiGetGithubLinkRequest {
	return ApiGetGithubLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetGithubLinkExecute(r ApiGetGithubLinkRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubLink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/link"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.redirectUrl != nil {
		localVarQueryParams.Add("redirectUrl", parameterToString(*r.redirectUrl, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubLoginRequest struct {
	ctx                _context.Context
	ApiService         *UserApiService
	redirectUrl        *string
	fromAuthorize      *string
	cliToken           *string
	cleverFlavor       *string
	oauthToken         *string
	invitationKey      *string
	subscriptionSource *string
}

func (r ApiGetGithubLoginRequest) RedirectUrl(redirectUrl string) ApiGetGithubLoginRequest {
	r.redirectUrl = &redirectUrl
	return r
}
func (r ApiGetGithubLoginRequest) FromAuthorize(fromAuthorize string) ApiGetGithubLoginRequest {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiGetGithubLoginRequest) CliToken(cliToken string) ApiGetGithubLoginRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiGetGithubLoginRequest) CleverFlavor(cleverFlavor string) ApiGetGithubLoginRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiGetGithubLoginRequest) OauthToken(oauthToken string) ApiGetGithubLoginRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiGetGithubLoginRequest) InvitationKey(invitationKey string) ApiGetGithubLoginRequest {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiGetGithubLoginRequest) SubscriptionSource(subscriptionSource string) ApiGetGithubLoginRequest {
	r.subscriptionSource = &subscriptionSource
	return r
}

func (r ApiGetGithubLoginRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetGithubLoginExecute(r)
}

/*
 * GetGithubLogin Method for GetGithubLogin
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubLoginRequest
 */
func (a *UserApiService) GetGithubLogin(ctx _context.Context) ApiGetGithubLoginRequest {
	return ApiGetGithubLoginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) GetGithubLoginExecute(r ApiGetGithubLoginRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubLogin")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.redirectUrl != nil {
		localVarQueryParams.Add("redirectUrl", parameterToString(*r.redirectUrl, ""))
	}
	if r.fromAuthorize != nil {
		localVarQueryParams.Add("fromAuthorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarQueryParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarQueryParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.invitationKey != nil {
		localVarQueryParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.subscriptionSource != nil {
		localVarQueryParams.Add("subscriptionSource", parameterToString(*r.subscriptionSource, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGithubUsernameRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
}

func (r ApiGetGithubUsernameRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetGithubUsernameExecute(r)
}

/*
 * GetGithubUsername Method for GetGithubUsername
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGithubUsernameRequest
 */
func (a *UserApiService) GetGithubUsername(ctx _context.Context) ApiGetGithubUsernameRequest {
	return ApiGetGithubUsernameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetGithubUsernameExecute(r ApiGetGithubUsernameRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetGithubUsername")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/username"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLoginFormRequest struct {
	ctx               _context.Context
	ApiService        *UserApiService
	secondaryEmailKey *string
	deletionKey       *string
	fromAuthorize     *string
	cliToken          *string
	cleverFlavor      *string
}

func (r ApiGetLoginFormRequest) SecondaryEmailKey(secondaryEmailKey string) ApiGetLoginFormRequest {
	r.secondaryEmailKey = &secondaryEmailKey
	return r
}
func (r ApiGetLoginFormRequest) DeletionKey(deletionKey string) ApiGetLoginFormRequest {
	r.deletionKey = &deletionKey
	return r
}
func (r ApiGetLoginFormRequest) FromAuthorize(fromAuthorize string) ApiGetLoginFormRequest {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiGetLoginFormRequest) CliToken(cliToken string) ApiGetLoginFormRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiGetLoginFormRequest) CleverFlavor(cleverFlavor string) ApiGetLoginFormRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiGetLoginFormRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetLoginFormExecute(r)
}

/*
 * GetLoginForm Method for GetLoginForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetLoginFormRequest
 */
func (a *UserApiService) GetLoginForm(ctx _context.Context) ApiGetLoginFormRequest {
	return ApiGetLoginFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetLoginFormExecute(r ApiGetLoginFormRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetLoginForm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.secondaryEmailKey != nil {
		localVarQueryParams.Add("secondaryEmailKey", parameterToString(*r.secondaryEmailKey, ""))
	}
	if r.deletionKey != nil {
		localVarQueryParams.Add("deletionKey", parameterToString(*r.deletionKey, ""))
	}
	if r.fromAuthorize != nil {
		localVarQueryParams.Add("fromAuthorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarQueryParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLoginForm1Request struct {
	ctx               _context.Context
	ApiService        *UserApiService
	secondaryEmailKey *string
	deletionKey       *string
	fromAuthorize     *string
	cliToken          *string
	cleverFlavor      *string
}

func (r ApiGetLoginForm1Request) SecondaryEmailKey(secondaryEmailKey string) ApiGetLoginForm1Request {
	r.secondaryEmailKey = &secondaryEmailKey
	return r
}
func (r ApiGetLoginForm1Request) DeletionKey(deletionKey string) ApiGetLoginForm1Request {
	r.deletionKey = &deletionKey
	return r
}
func (r ApiGetLoginForm1Request) FromAuthorize(fromAuthorize string) ApiGetLoginForm1Request {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiGetLoginForm1Request) CliToken(cliToken string) ApiGetLoginForm1Request {
	r.cliToken = &cliToken
	return r
}
func (r ApiGetLoginForm1Request) CleverFlavor(cleverFlavor string) ApiGetLoginForm1Request {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiGetLoginForm1Request) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetLoginForm1Execute(r)
}

/*
 * GetLoginForm1 Method for GetLoginForm1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetLoginForm1Request
 */
func (a *UserApiService) GetLoginForm1(ctx _context.Context) ApiGetLoginForm1Request {
	return ApiGetLoginForm1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetLoginForm1Execute(r ApiGetLoginForm1Request) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetLoginForm1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sessions/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.secondaryEmailKey != nil {
		localVarQueryParams.Add("secondaryEmailKey", parameterToString(*r.secondaryEmailKey, ""))
	}
	if r.deletionKey != nil {
		localVarQueryParams.Add("deletionKey", parameterToString(*r.deletionKey, ""))
	}
	if r.fromAuthorize != nil {
		localVarQueryParams.Add("fromAuthorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarQueryParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPasswordForgottenFormRequest struct {
	ctx          _context.Context
	ApiService   *UserApiService
	cleverFlavor *string
}

func (r ApiGetPasswordForgottenFormRequest) CleverFlavor(cleverFlavor string) ApiGetPasswordForgottenFormRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiGetPasswordForgottenFormRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetPasswordForgottenFormExecute(r)
}

/*
 * GetPasswordForgottenForm Method for GetPasswordForgottenForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetPasswordForgottenFormRequest
 */
func (a *UserApiService) GetPasswordForgottenForm(ctx _context.Context) ApiGetPasswordForgottenFormRequest {
	return ApiGetPasswordForgottenFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetPasswordForgottenFormExecute(r ApiGetPasswordForgottenFormRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetPasswordForgottenForm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/password_forgotten"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignupFormRequest struct {
	ctx           _context.Context
	ApiService    *UserApiService
	invitationKey *string
	urlNext       *string
	cleverFlavor  *string
}

func (r ApiGetSignupFormRequest) InvitationKey(invitationKey string) ApiGetSignupFormRequest {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiGetSignupFormRequest) UrlNext(urlNext string) ApiGetSignupFormRequest {
	r.urlNext = &urlNext
	return r
}
func (r ApiGetSignupFormRequest) CleverFlavor(cleverFlavor string) ApiGetSignupFormRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiGetSignupFormRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSignupFormExecute(r)
}

/*
 * GetSignupForm Method for GetSignupForm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSignupFormRequest
 */
func (a *UserApiService) GetSignupForm(ctx _context.Context) ApiGetSignupFormRequest {
	return ApiGetSignupFormRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetSignupFormExecute(r ApiGetSignupFormRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetSignupForm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/signup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.invitationKey != nil {
		localVarQueryParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.urlNext != nil {
		localVarQueryParams.Add("url_next", parameterToString(*r.urlNext, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignupForm1Request struct {
	ctx           _context.Context
	ApiService    *UserApiService
	invitationKey *string
	urlNext       *string
	cleverFlavor  *string
}

func (r ApiGetSignupForm1Request) InvitationKey(invitationKey string) ApiGetSignupForm1Request {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiGetSignupForm1Request) UrlNext(urlNext string) ApiGetSignupForm1Request {
	r.urlNext = &urlNext
	return r
}
func (r ApiGetSignupForm1Request) CleverFlavor(cleverFlavor string) ApiGetSignupForm1Request {
	r.cleverFlavor = &cleverFlavor
	return r
}

func (r ApiGetSignupForm1Request) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSignupForm1Execute(r)
}

/*
 * GetSignupForm1 Method for GetSignupForm1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSignupForm1Request
 */
func (a *UserApiService) GetSignupForm1(ctx _context.Context) ApiGetSignupForm1Request {
	return ApiGetSignupForm1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) GetSignupForm1Execute(r ApiGetSignupForm1Request) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetSignupForm1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sessions/signup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.invitationKey != nil {
		localVarQueryParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.urlNext != nil {
		localVarQueryParams.Add("url_next", parameterToString(*r.urlNext, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserByIdRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	id         string
}

func (r ApiGetUserByIdRequest) Execute() (UserView, *_nethttp.Response, error) {
	return r.ApiService.GetUserByIdExecute(r)
}

/*
 * GetUserById Method for GetUserById
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGetUserByIdRequest
 */
func (a *UserApiService) GetUserById(ctx _context.Context, id string) ApiGetUserByIdRequest {
	return ApiGetUserByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return UserView
 */
func (a *UserApiService) GetUserByIdExecute(r ApiGetUserByIdRequest) (UserView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GetUserById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGithubSignupRequest struct {
	ctx                _context.Context
	ApiService         *UserApiService
	redirectUrl        *string
	fromAuthorize      *string
	cliToken           *string
	cleverFlavor       *string
	oauthToken         *string
	invitationKey      *string
	subscriptionSource *string
	terms              *string
}

func (r ApiGithubSignupRequest) RedirectUrl(redirectUrl string) ApiGithubSignupRequest {
	r.redirectUrl = &redirectUrl
	return r
}
func (r ApiGithubSignupRequest) FromAuthorize(fromAuthorize string) ApiGithubSignupRequest {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiGithubSignupRequest) CliToken(cliToken string) ApiGithubSignupRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiGithubSignupRequest) CleverFlavor(cleverFlavor string) ApiGithubSignupRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiGithubSignupRequest) OauthToken(oauthToken string) ApiGithubSignupRequest {
	r.oauthToken = &oauthToken
	return r
}
func (r ApiGithubSignupRequest) InvitationKey(invitationKey string) ApiGithubSignupRequest {
	r.invitationKey = &invitationKey
	return r
}
func (r ApiGithubSignupRequest) SubscriptionSource(subscriptionSource string) ApiGithubSignupRequest {
	r.subscriptionSource = &subscriptionSource
	return r
}
func (r ApiGithubSignupRequest) Terms(terms string) ApiGithubSignupRequest {
	r.terms = &terms
	return r
}

func (r ApiGithubSignupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GithubSignupExecute(r)
}

/*
 * GithubSignup Method for GithubSignup
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGithubSignupRequest
 */
func (a *UserApiService) GithubSignup(ctx _context.Context) ApiGithubSignupRequest {
	return ApiGithubSignupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) GithubSignupExecute(r ApiGithubSignupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.GithubSignup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/signup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.redirectUrl != nil {
		localVarQueryParams.Add("redirectUrl", parameterToString(*r.redirectUrl, ""))
	}
	if r.fromAuthorize != nil {
		localVarQueryParams.Add("fromAuthorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarQueryParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarQueryParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarQueryParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	if r.invitationKey != nil {
		localVarQueryParams.Add("invitationKey", parameterToString(*r.invitationKey, ""))
	}
	if r.subscriptionSource != nil {
		localVarQueryParams.Add("subscriptionSource", parameterToString(*r.subscriptionSource, ""))
	}
	if r.terms != nil {
		localVarQueryParams.Add("terms", parameterToString(*r.terms, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLoginRequest struct {
	ctx           _context.Context
	ApiService    *UserApiService
	email         *string
	pass          *string
	fromAuthorize *string
	cliToken      *string
	cleverFlavor  *string
	oauthToken    *string
}

func (r ApiLoginRequest) Email(email string) ApiLoginRequest {
	r.email = &email
	return r
}
func (r ApiLoginRequest) Pass(pass string) ApiLoginRequest {
	r.pass = &pass
	return r
}
func (r ApiLoginRequest) FromAuthorize(fromAuthorize string) ApiLoginRequest {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiLoginRequest) CliToken(cliToken string) ApiLoginRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiLoginRequest) CleverFlavor(cleverFlavor string) ApiLoginRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiLoginRequest) OauthToken(oauthToken string) ApiLoginRequest {
	r.oauthToken = &oauthToken
	return r
}

func (r ApiLoginRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.LoginExecute(r)
}

/*
 * Login Method for Login
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLoginRequest
 */
func (a *UserApiService) Login(ctx _context.Context) ApiLoginRequest {
	return ApiLoginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) LoginExecute(r ApiLoginRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.Login")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.email != nil {
		localVarFormParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.pass != nil {
		localVarFormParams.Add("pass", parameterToString(*r.pass, ""))
	}
	if r.fromAuthorize != nil {
		localVarFormParams.Add("from_authorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarFormParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogin1Request struct {
	ctx           _context.Context
	ApiService    *UserApiService
	email         *string
	pass          *string
	fromAuthorize *string
	cliToken      *string
	cleverFlavor  *string
	oauthToken    *string
}

func (r ApiLogin1Request) Email(email string) ApiLogin1Request {
	r.email = &email
	return r
}
func (r ApiLogin1Request) Pass(pass string) ApiLogin1Request {
	r.pass = &pass
	return r
}
func (r ApiLogin1Request) FromAuthorize(fromAuthorize string) ApiLogin1Request {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiLogin1Request) CliToken(cliToken string) ApiLogin1Request {
	r.cliToken = &cliToken
	return r
}
func (r ApiLogin1Request) CleverFlavor(cleverFlavor string) ApiLogin1Request {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiLogin1Request) OauthToken(oauthToken string) ApiLogin1Request {
	r.oauthToken = &oauthToken
	return r
}

func (r ApiLogin1Request) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.Login1Execute(r)
}

/*
 * Login1 Method for Login1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLogin1Request
 */
func (a *UserApiService) Login1(ctx _context.Context) ApiLogin1Request {
	return ApiLogin1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) Login1Execute(r ApiLogin1Request) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.Login1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sessions/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.email != nil {
		localVarFormParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.pass != nil {
		localVarFormParams.Add("pass", parameterToString(*r.pass, ""))
	}
	if r.fromAuthorize != nil {
		localVarFormParams.Add("from_authorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarFormParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMfaLoginRequest struct {
	ctx           _context.Context
	ApiService    *UserApiService
	mfaKind       *string
	mfaAttempt    *string
	email         *string
	authId        *string
	fromAuthorize *string
	cliToken      *string
	cleverFlavor  *string
	oauthToken    *string
}

func (r ApiMfaLoginRequest) MfaKind(mfaKind string) ApiMfaLoginRequest {
	r.mfaKind = &mfaKind
	return r
}
func (r ApiMfaLoginRequest) MfaAttempt(mfaAttempt string) ApiMfaLoginRequest {
	r.mfaAttempt = &mfaAttempt
	return r
}
func (r ApiMfaLoginRequest) Email(email string) ApiMfaLoginRequest {
	r.email = &email
	return r
}
func (r ApiMfaLoginRequest) AuthId(authId string) ApiMfaLoginRequest {
	r.authId = &authId
	return r
}
func (r ApiMfaLoginRequest) FromAuthorize(fromAuthorize string) ApiMfaLoginRequest {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiMfaLoginRequest) CliToken(cliToken string) ApiMfaLoginRequest {
	r.cliToken = &cliToken
	return r
}
func (r ApiMfaLoginRequest) CleverFlavor(cleverFlavor string) ApiMfaLoginRequest {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiMfaLoginRequest) OauthToken(oauthToken string) ApiMfaLoginRequest {
	r.oauthToken = &oauthToken
	return r
}

func (r ApiMfaLoginRequest) Execute() ([]OAuthApplicationView, *_nethttp.Response, error) {
	return r.ApiService.MfaLoginExecute(r)
}

/*
 * MfaLogin Method for MfaLogin
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMfaLoginRequest
 */
func (a *UserApiService) MfaLogin(ctx _context.Context) ApiMfaLoginRequest {
	return ApiMfaLoginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OAuthApplicationView
 */
func (a *UserApiService) MfaLoginExecute(r ApiMfaLoginRequest) ([]OAuthApplicationView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OAuthApplicationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.MfaLogin")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/mfa_login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.mfaKind != nil {
		localVarFormParams.Add("mfa_kind", parameterToString(*r.mfaKind, ""))
	}
	if r.mfaAttempt != nil {
		localVarFormParams.Add("mfa_attempt", parameterToString(*r.mfaAttempt, ""))
	}
	if r.email != nil {
		localVarFormParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.authId != nil {
		localVarFormParams.Add("auth_id", parameterToString(*r.authId, ""))
	}
	if r.fromAuthorize != nil {
		localVarFormParams.Add("from_authorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarFormParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMfaLogin1Request struct {
	ctx           _context.Context
	ApiService    *UserApiService
	mfaKind       *string
	mfaAttempt    *string
	email         *string
	authId        *string
	fromAuthorize *string
	cliToken      *string
	cleverFlavor  *string
	oauthToken    *string
}

func (r ApiMfaLogin1Request) MfaKind(mfaKind string) ApiMfaLogin1Request {
	r.mfaKind = &mfaKind
	return r
}
func (r ApiMfaLogin1Request) MfaAttempt(mfaAttempt string) ApiMfaLogin1Request {
	r.mfaAttempt = &mfaAttempt
	return r
}
func (r ApiMfaLogin1Request) Email(email string) ApiMfaLogin1Request {
	r.email = &email
	return r
}
func (r ApiMfaLogin1Request) AuthId(authId string) ApiMfaLogin1Request {
	r.authId = &authId
	return r
}
func (r ApiMfaLogin1Request) FromAuthorize(fromAuthorize string) ApiMfaLogin1Request {
	r.fromAuthorize = &fromAuthorize
	return r
}
func (r ApiMfaLogin1Request) CliToken(cliToken string) ApiMfaLogin1Request {
	r.cliToken = &cliToken
	return r
}
func (r ApiMfaLogin1Request) CleverFlavor(cleverFlavor string) ApiMfaLogin1Request {
	r.cleverFlavor = &cleverFlavor
	return r
}
func (r ApiMfaLogin1Request) OauthToken(oauthToken string) ApiMfaLogin1Request {
	r.oauthToken = &oauthToken
	return r
}

func (r ApiMfaLogin1Request) Execute() ([]OAuthApplicationView, *_nethttp.Response, error) {
	return r.ApiService.MfaLogin1Execute(r)
}

/*
 * MfaLogin1 Method for MfaLogin1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMfaLogin1Request
 */
func (a *UserApiService) MfaLogin1(ctx _context.Context) ApiMfaLogin1Request {
	return ApiMfaLogin1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OAuthApplicationView
 */
func (a *UserApiService) MfaLogin1Execute(r ApiMfaLogin1Request) ([]OAuthApplicationView, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OAuthApplicationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.MfaLogin1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sessions/mfa_login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.mfaKind != nil {
		localVarFormParams.Add("mfa_kind", parameterToString(*r.mfaKind, ""))
	}
	if r.mfaAttempt != nil {
		localVarFormParams.Add("mfa_attempt", parameterToString(*r.mfaAttempt, ""))
	}
	if r.email != nil {
		localVarFormParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.authId != nil {
		localVarFormParams.Add("auth_id", parameterToString(*r.authId, ""))
	}
	if r.fromAuthorize != nil {
		localVarFormParams.Add("from_authorize", parameterToString(*r.fromAuthorize, ""))
	}
	if r.cliToken != nil {
		localVarFormParams.Add("cli_token", parameterToString(*r.cliToken, ""))
	}
	if r.cleverFlavor != nil {
		localVarFormParams.Add("clever_flavor", parameterToString(*r.cleverFlavor, ""))
	}
	if r.oauthToken != nil {
		localVarFormParams.Add("oauth_token", parameterToString(*r.oauthToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGithubRedeployRequest struct {
	ctx                  _context.Context
	ApiService           *UserApiService
	githubWebhookPayload *GithubWebhookPayload
	userAgent            *string
	xGithubEvent         *string
	xHubSignature        *string
}

func (r ApiPostGithubRedeployRequest) GithubWebhookPayload(githubWebhookPayload GithubWebhookPayload) ApiPostGithubRedeployRequest {
	r.githubWebhookPayload = &githubWebhookPayload
	return r
}
func (r ApiPostGithubRedeployRequest) UserAgent(userAgent string) ApiPostGithubRedeployRequest {
	r.userAgent = &userAgent
	return r
}
func (r ApiPostGithubRedeployRequest) XGithubEvent(xGithubEvent string) ApiPostGithubRedeployRequest {
	r.xGithubEvent = &xGithubEvent
	return r
}
func (r ApiPostGithubRedeployRequest) XHubSignature(xHubSignature string) ApiPostGithubRedeployRequest {
	r.xHubSignature = &xHubSignature
	return r
}

func (r ApiPostGithubRedeployRequest) Execute() (Message, *_nethttp.Response, error) {
	return r.ApiService.PostGithubRedeployExecute(r)
}

/*
 * PostGithubRedeploy Method for PostGithubRedeploy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPostGithubRedeployRequest
 */
func (a *UserApiService) PostGithubRedeploy(ctx _context.Context) ApiPostGithubRedeployRequest {
	return ApiPostGithubRedeployRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Message
 */
func (a *UserApiService) PostGithubRedeployExecute(r ApiPostGithubRedeployRequest) (Message, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.PostGithubRedeploy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/github/redeploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.githubWebhookPayload == nil {
		return localVarReturnValue, nil, reportError("githubWebhookPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.userAgent != nil {
		localVarHeaderParams["User-Agent"] = parameterToString(*r.userAgent, "")
	}
	if r.xGithubEvent != nil {
		localVarHeaderParams["X-Github-Event"] = parameterToString(*r.xGithubEvent, "")
	}
	if r.xHubSignature != nil {
		localVarHeaderParams["X-Hub-Signature"] = parameterToString(*r.xHubSignature, "")
	}
	// body params
	localVarPostBody = r.githubWebhookPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetPasswordForgottenRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	key        string
	pass       *string
	pass2      *string
}

func (r ApiResetPasswordForgottenRequest) Pass(pass string) ApiResetPasswordForgottenRequest {
	r.pass = &pass
	return r
}
func (r ApiResetPasswordForgottenRequest) Pass2(pass2 string) ApiResetPasswordForgottenRequest {
	r.pass2 = &pass2
	return r
}

func (r ApiResetPasswordForgottenRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.ResetPasswordForgottenExecute(r)
}

/*
 * ResetPasswordForgotten Method for ResetPasswordForgotten
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param key
 * @return ApiResetPasswordForgottenRequest
 */
func (a *UserApiService) ResetPasswordForgotten(ctx _context.Context, key string) ApiResetPasswordForgottenRequest {
	return ApiResetPasswordForgottenRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *UserApiService) ResetPasswordForgottenExecute(r ApiResetPasswordForgottenRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.ResetPasswordForgotten")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/password_forgotten/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.pass != nil {
		localVarFormParams.Add("pass", parameterToString(*r.pass, ""))
	}
	if r.pass2 != nil {
		localVarFormParams.Add("pass2", parameterToString(*r.pass2, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEnvRequest struct {
	ctx        _context.Context
	ApiService *UserApiService
	appId      string
	body       *string
	token      *string
}

func (r ApiUpdateEnvRequest) Body(body string) ApiUpdateEnvRequest {
	r.body = &body
	return r
}
func (r ApiUpdateEnvRequest) Token(token string) ApiUpdateEnvRequest {
	r.token = &token
	return r
}

func (r ApiUpdateEnvRequest) Execute() (Message, *_nethttp.Response, error) {
	return r.ApiService.UpdateEnvExecute(r)
}

/*
 * UpdateEnv Method for UpdateEnv
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId
 * @return ApiUpdateEnvRequest
 */
func (a *UserApiService) UpdateEnv(ctx _context.Context, appId string) ApiUpdateEnvRequest {
	return ApiUpdateEnvRequest{
		ApiService: a,
		ctx:        ctx,
		appId:      appId,
	}
}

/*
 * Execute executes the request
 * @return Message
 */
func (a *UserApiService) UpdateEnvExecute(r ApiUpdateEnvRequest) (Message, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UpdateEnv")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/application/{appId}/environment"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", _neturl.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInvoiceRequest struct {
	ctx                  _context.Context
	ApiService           *UserApiService
	bid                  string
	endOfInvoiceResponse *EndOfInvoiceResponse
}

func (r ApiUpdateInvoiceRequest) EndOfInvoiceResponse(endOfInvoiceResponse EndOfInvoiceResponse) ApiUpdateInvoiceRequest {
	r.endOfInvoiceResponse = &endOfInvoiceResponse
	return r
}

func (r ApiUpdateInvoiceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateInvoiceExecute(r)
}

/*
 * UpdateInvoice Method for UpdateInvoice
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bid
 * @return ApiUpdateInvoiceRequest
 */
func (a *UserApiService) UpdateInvoice(ctx _context.Context, bid string) ApiUpdateInvoiceRequest {
	return ApiUpdateInvoiceRequest{
		ApiService: a,
		ctx:        ctx,
		bid:        bid,
	}
}

/*
 * Execute executes the request
 */
func (a *UserApiService) UpdateInvoiceExecute(r ApiUpdateInvoiceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UpdateInvoice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoice/external/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", _neturl.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.endOfInvoiceResponse == nil {
		return nil, reportError("endOfInvoiceResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endOfInvoiceResponse
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
